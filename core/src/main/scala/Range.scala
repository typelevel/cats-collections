package dogs

import dogs.Order._
import dogs.Predef._

import scala.annotation.tailrec

/**
  * Represent a range [x, y] that can be generated by using discrete operations
  */
sealed class Range[A](val start: A, val end: A) {

  /**
    * Calculate the difference with range.
    *
    * It returns a tuple with the difference to the right and to the left of range.
    *
    * It basically calculates what is to the left of range that is in this and what is to the right
    * of range that is in this (in both cases it does not include elements in range)
    */
  def -(range: Range[A])(implicit discrete: Enum[A]): (Range[A], Range[A]) = {
    if (discrete.compare(end, range.start) == LT) {
      (this, Range.empty[A]())
    }
    else if (discrete.compare(start, range.end) == GT) {
      (Range.empty[A](), this)
    }
    else {
      (discrete.compare(start, range.start), discrete.compare(end, range.end)) match {
        case (EQ, GT) => (Range.empty(), Range(discrete.succ(range.end), end))
        case (EQ, _)  => (Range.empty(), Range.empty())

        case (GT, GT) => (Range.empty(), Range(discrete.succ(range.end), end))
        case (GT, _)  => (Range.empty(), Range.empty())

        case (LT, GT) => (Range(start, discrete.pred(range.start)), Range(discrete.succ(range.end), end))
        case (LT, _)  => (Range(start, discrete.pred(range.start)), Range.empty())
      }
    }
  }

  /**
    * Verify that the passed range is within
    */
  def contains(range: Range[A])(implicit discrete: Enum[A]) =
     discrete.le(start, range.start) && discrete.ge(end, range.end)

  /**
    * Generates the elements of the range [start, end] base of the discrete operations
    */
  def generate(implicit discrete: Enum[A]): List[A] = gen (start, end, List.empty)(_=>{})

  /**
    * Returns range [end, start]
    */
  def reverse(implicit discrete: Enum[A]): Range[A] = Range(end, start)

  /**
    * Verify is x is in range [start, end]
    */
  def contains(x: A)(implicit discrete: Enum[A]) = discrete.ge(x, start) && discrete.le(x, end)

  /**
   * Return all the values in the Range as a List
   */
  def toList(implicit A: Enum[A]): List[A] = {
    val lb = new ListBuilder[A]
    foreach(lb += _)
    lb.run
  }

  /**
    * Apply function f to each element in range [star, end]
    */
  def foreach(f: A => Unit)(implicit discrete: Enum[A]): Unit = {
    val ignore = gen(start, end, List.empty)(f)
  }

  def map[B](f: A => B)(implicit discrete: Enum[A]): List[B] =
    genMap[B](start, end, List.empty)(f)

  def foldLeft[B](s: B, f: (B, A) => B)(implicit discrete: Enum[A]): B =
    generate.foldLeft(s)(f)

  private def genMap[B](x: A, y: A, xs: List[B])(f: A => B)(implicit discrete: Enum[A]): List[B] = {
    @tailrec def traverse(a: A, b: A, xs: List[B])(f: A => B)(implicit discrete: Enum[A]): List[B] = {

      if (discrete.compare(a, b) == EQ) {
        xs ::: Nel(f(a), List.empty)
      } else if (discrete.adj(a, b)) {
        xs ::: Nel(f(a), Nel(f(b), List.empty))
      } else {
        traverse(discrete.succ(a), b, xs ::: (Nel(f(a), List.empty)))(f)
      }
    }

    if (discrete.lt(x, y))
      traverse(x, y, xs)(f)
    else
      traverse(x, y, xs)(f)(new Enum[A] {
        override def pred(x: A): A = discrete.succ(x)
        override def succ(x: A): A = discrete.pred(x)
        override def apply(l: A, r: A): Ordering = discrete.apply(l, r)
      })
  }

  private def gen(x: A, y: A, xs: List[A])(f: A=>Unit)(implicit discrete: Enum[A]): List[A] = {
  @tailrec def traverse(a: A, b: A, xs: List[A])(f: A => Unit)(implicit discrete: Enum[A]): List[A] = {

      if (discrete.compare(a, b) == EQ) {
        f(a)
        xs ::: Nel(a, List.empty)
      } else if (discrete.adj(a, b)) {
        f(a)
        f(b)
        xs ::: Nel(a, Nel(b, List.empty))
      }
      else {
        f(a)
        traverse(discrete.succ(a), b, xs ::: (Nel(a, List.empty)))(f)
      }
    }

    if (discrete.lt(x, y))
      traverse(x, y, xs)(f)
    else
      traverse(x, y, xs)(f)(new Enum[A] {
        override def pred(x: A): A = discrete.succ(x)
        override def succ(x: A): A = discrete.pred(x)
        override def apply(l: A, r: A): Ordering = discrete.apply(l, r)
      })
  }

  private [dogs] def isEmpty: Boolean = false

  def apply(start: A, end: A): Range[A] = Range.apply(start, end)

  override def toString: String = if (isEmpty) s"[]" else s"[$start,$end]"
}

object Range {
  def apply[A](x: A, y: A) = new Range[A](x, y)

  def empty[A](): Range[A] = EmptyRange()


  private [dogs] case object EmptyRange extends Range[Option[Nothing]](None(), None()) {
    def apply[A]() = this.asInstanceOf[A]

    def unapply[A](r: Range[A]) = r.isEmpty

    override def isEmpty = true
  }
}
