/**
  * Created by Nicolas A Perez (@anicolaspp) on 2/8/16.
  */

package dogs

import dogs.Order._
import dogs.Predef._

import scala.annotation.tailrec

/**
  * Represent a range [x, y] that can be generated by using discrete operations
  */
sealed class Range[A](val start: A, val end: A) {

  /**
    * Calculate the difference with range.
    *
    * It returns a tuple with the difference to the right and to the left of range.
    *
    * It basically calculates what is to the left of range that is in this and what is to the right
    * of range that is in this (in both cases it does not include elements in range)
    */
  def -(range: Range[A])(implicit discrete: Enum[A]): (Range[A], Range[A]) = {
    if (discrete.compare(end, range.start) == LT) {
      (this, Range.empty[A]())
    }
    else if (discrete.compare(start, range.end) == GT) {
      (Range.empty[A](), this)
    }
    else {
      (discrete.compare(start, range.start), discrete.compare(end, range.end)) match {
        case (EQ, EQ) => (Range.empty(), Range.empty())
        case (EQ, LT) => (Range.empty(), Range.empty())
        case (EQ, GT) => (Range.empty(), Range(discrete.succ(range.end), end))

        case (GT, EQ) => (Range.empty(), Range.empty())
        case (LT, EQ) => (Range(start, discrete.pred(range.start)), Range.empty())

        case (GT, GT) => (Range.empty(), Range(discrete.succ(range.end), end))

        case (LT, LT) => (Range(start, discrete.pred(range.start)), Range.empty())

        case (GT, LT) => (Range.empty(), Range.empty())
        case (LT, GT) => (Range(start, discrete.pred(range.start)), Range(discrete.succ(range.end), end))
      }
    }
  }

  /**
    * Verify that the passed range is within
    */
  def contains(range: Range[A])(implicit discrete: Enum[A]) =
     discrete.le(start, range.start) && discrete.ge(end, range.end)

  /**
    * Generates the elements of the range [start, end] base of the discrete operations
    */
  def generate(implicit discrete: Enum[A]): List[A] = gen (start, end, El())(_=>{})

  /**
    * Generates the elements of the range [end, start] base of the discrete operations
    */
  def reverse(implicit discrete: Enum[A]): List[A] = {
    gen(end, start, El())(_=>{})(new Enum[A] {
      override def pred(x: A): A = discrete.succ(x)
      override def succ(x: A): A = discrete.pred(x)
      override def apply(l: A, r: A): Ordering = discrete.apply(l, r)
    })
  }

  /**
    * Verify is x is in range [start, end]
    */
  def contains(x: A)(implicit discrete: Enum[A]) = discrete.ge(x, start) && discrete.le(x, end)

  /**
    * Apply function f to each element in range [star, end]
    */
  def foreach(f: A => Unit)(implicit discrete: Enum[A]): Unit = {
    val ignore = gen(start, end, El())(f)
  }

  def map[B](f: A => B)(implicit discrete: Enum[A]): List[B] =
    genMap[B](start, end, El())(f)

  def foldLeft[B](s: B, f: (B, A) => B)(implicit discrete: Enum[A]): B =
    generate.foldLeft(s)(f)

  @tailrec private def genMap[B](a: A, b: A, xs: List[B])(f: A => B)(implicit discrete: Enum[A]): List[B] = {
    if (discrete.compare(a, b) == EQ) {
      xs ::: Nel(f(a), El())
    } else if (discrete.adj(a, b)) {

      xs ::: Nel(f(a), Nel(f(b), El()))
    } else {
      genMap(discrete.succ(a), b, xs ::: (Nel(f(a), El())))(f)
    }
  }

  @tailrec private def gen(a: A, b: A, xs: List[A])(f: A=>Unit)(implicit discrete: Enum[A]): List[A] = {
      if (discrete.compare(a, b) == EQ) {
        f(a)
        xs ::: Nel(a, El())
      } else if (discrete.adj(a, b)) {
        f(a)
        f(b)
        xs ::: Nel(a, Nel(b, El()))
      }
      else {
        f(a)
        gen(discrete.succ(a), b, xs ::: (Nel(a, El())))(f)
      }
    }

  private [dogs] def isEmpty: Boolean = false

  def apply(start: A, end: A): Range[A] = Range.apply(start, end)
}

object Range {
  def apply[A](x: A, y: A) = new Range[A](x, y)

  def empty[A](): Range[A] = EmptyRange()


  private [dogs] case object EmptyRange extends Range[Option[Nothing]](None(), None()) {
    def apply[A]() = this.asInstanceOf[A]

    def unapply[A](r: Range[A]) = r.isEmpty

    override def isEmpty = true
  }
}
